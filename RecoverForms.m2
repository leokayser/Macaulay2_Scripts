HFtable = method(Dispatch => Thing, Options => {Range => null})
HFtable Sequence := o -> Is -> (
    idealList = toList Is;
    d := if o.Range === null then max apply(idealList, I -> regularity I) else o.Range;
    netList transpose for i from 0 to d list {i} | apply(idealList, I -> hilbertFunction({i},I))
)
HFtable Ideal := o -> I -> (
    d := if o.Range === null then regularity I else o.Range;
    netList transpose for i from 0 to d list {i, hilbertFunction({i},I)}
)

degStr := f -> if f == 0 then " " else toString sum degree f;

degTable = method()
degTable Matrix := M -> netList applyTable(entries M, degStr)
degTable ChainComplex := C -> apply(1..(length C), i -> degTable C.dd_i)

chop = method() -- This gives the ideal generated by elements of degree UP TO d.
chop (Ideal,ZZ) := (I,d) -> (
    lowGens := select(flatten entries gens I, f -> (degree f)#0 <= d);
    return if #lowGens == 0 then ideal 0_(ring I) else ideal lowGens;
)
chop Ideal := I -> (
    d := min apply(flatten entries gens I, f -> (degree f)#0);
    chop(I,d)
)

recover = method(Options => {DividedPowers => true})
recover (RingElement,ZZ) := o -> (F,k) -> (
    d := (degree F)#0;
    I := inverseSystem(F, DividedPowers=>o.DividedPowers);
    J := chop(I,k);
    result := perp(J,d);
    return if o.DividedPowers then result else fromDividedPowers(result);
)

perp = method(Options => {DividedPowers => true}) -- Assumes you are handling divided powers correctly!
perp (Ideal,ZZ) := o -> (J,d) -> (
    if J == 0 then return super basis(d, ring J); -- Avoid "0xm matrix" problem
    W := super basis(d,J);
    monomialBasis := flatten entries super basis(d,ring J);
    KK := coefficientRing ring J;
    A := matrix (flatten entries W / (f -> flatten entries sub(last coefficients(f,Monomials=>monomialBasis), KK)));
    sols := (ker A).generators;
    return (matrix {monomialBasis}) * sols;
)

end
--------
restart
load "RecoverForms.m2"

S = QQ[X..Z];
F = random(5,S);
ideal recover(F,3) == ideal F
I = inverseSystem(F, DividedPowers=>true)
minimalBetti I
J = chop(I,3)
HFtable(I,J)



d = 5; t = (d+1)/2;
F = random(d, S, Height=>2);
I = inverseSystem(F, DividedPowers=>true);

minimalBetti I
HFtable(I, chop I)
degTable res I
recover(F,3) == ideal F


q = for i from 1 to 6 list random(2,S, Height=>2)
auxRing = QQ[c_0..c_9]
P = sub(genericSkewMatrix(auxRing,5), matrix{{x_0,x_1,0,0,q_0,q_1,q_2,q_3,q_4,q_5}});

assert(P + transpose P == 0); degTable P
I = pfaffians(4,P)
HFtable(I, chop I)